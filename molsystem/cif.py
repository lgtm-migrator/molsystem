# -*- coding: utf-8 -*-

"""Functions for handling CIF files

Bond Orders
-----------
1 sing	single bond
2 doub	double bond
3 trip	triple bond
4 quad	quadruple bond
5 arom	aromatic bond
6 delo	delocalized double bond
7 pi	pi bond
8 poly	polymeric bond
"""

import io
import logging
import math

import CifFile

logger = logging.getLogger(__name__)

bond_order = {
    1: 'SING',
    2: 'DOUB',
    3: 'TRIP',
    4: 'QUAD',
    5: 'AROM',
    6: 'DELO',
    7: 'PI',
    8: 'POLY'
}
to_bond_order = {j: i for i, j in bond_order.items()}


class CIFMixin:
    """A mixin for handling CIF files."""

    def to_cif_text(self):
        """Create the text of a CIF file from this configuration.

        Returns
        -------
        text : str
            The text of the file.
        """

        lines = []

        atoms = self.atoms

        # Get the chemical formula
        formula, empirical_formula, Z = self.formula

        _id = empirical_formula.replace(' ', '')

        # And created the file, line-by-line
        lines = []
        lines.append('# Generated by MolSSI SEAMM')
        lines.append(f"data_{_id}")

        # Cell information
        if self.periodicity == 3:
            cell = self.cell
            a, b, c, alpha, beta, gamma = cell.parameters
            volume = cell.volume
            lines.append("_symmetry_space_group_name_H-M   'P 1'")
            lines.append(f'_cell_length_a   {a}')
            lines.append(f'_cell_length_b   {b}')
            lines.append(f'_cell_length_c   {c}')
            lines.append(f'_cell_angle_alpha   {alpha}')
            lines.append(f'_cell_angle_beta    {beta}')
            lines.append(f'_cell_angle_gamma   {gamma}')
            lines.append('_symmetry_Int_Tables_number   1')
            lines.append(f'_cell_volume   {volume}')
            lines.append(f'_cell_formula_units_Z   {Z}')
            lines.append('loop_')
            lines.append(' _symmetry_equiv_pos_site_id')
            lines.append(' _symmetry_equiv_pos_as_xyz')
            lines.append("  1  'x, y, z'")

        lines.append(f'_chemical_formula_structural   {empirical_formula}')
        lines.append(f"_chemical_formula_sum   '{formula}'")

        # The atoms
        lines.append('loop_')
        lines.append(' _atom_site_type_symbol')
        lines.append(' _atom_site_label')
        lines.append(' _atom_site_symmetry_multiplicity')
        lines.append(' _atom_site_fract_x')
        lines.append(' _atom_site_fract_y')
        lines.append(' _atom_site_fract_z')
        lines.append(' _atom_site_occupancy')

        # Need unique names
        if 'names' in atoms:
            original_names = atoms.get_column('names')
        else:
            original_names = atoms.symbols

        names = []
        tmp = {}
        for name in original_names:
            if name in tmp:
                tmp[name] += 1
                names.append(name + str(tmp[name]))
            else:
                tmp[name] = 1
                names.append(name)

        UVW = atoms.get_coordinates(fractionals=True, in_cell='molecule')

        symbols = atoms.symbols
        for element, name, uvw in zip(symbols, names, UVW):
            u, v, w = uvw
            lines.append(f'{element} {name}  1  {u:.3f} {v:.3f} {w:.3f}  1')

        # And that is it!
        return '\n'.join(lines)

    def from_cif_text(self, text):
        """Create this configuration from a CIF file..

        Parameters
        ----------
        text : str
            The text from the CIF file

        Returns
        -------
        None
        """

        cif = CifFile.ReadCif(io.StringIO(text))

        data_blocks = [*cif.keys()]

        if len(data_blocks) != 1:
            raise RuntimeError(
                f'There are {len(data_blocks)} data blocks in the cif file.'
            )
        data_block = cif[data_blocks[0]]

        # Reset the system
        self.clear()
        self.periodicity = 3
        self.coordinate_system = 'fractional'

        # The cell
        a = data_block['_cell_length_a']
        b = data_block['_cell_length_b']
        c = data_block['_cell_length_c']
        alpha = data_block['_cell_angle_alpha']
        beta = data_block['_cell_angle_beta']
        gamma = data_block['_cell_angle_gamma']
        self.cell.parameters = (a, b, c, alpha, beta, gamma)

        # Add the atoms
        # TEMPORARILY lower the symmetry to P1
        delta = 1.0e-04
        for x, y, z, symbol in zip(
            data_block['_atom_site_fract_x'],
            data_block['_atom_site_fract_y'],
            data_block['_atom_site_fract_z'],
            data_block['_atom_site_type_symbol']
        ):  # yapf: disable
            xs = []
            ys = []
            zs = []
            symbols = []
            # These variables *are* used in the eval below.
            x = float(x)
            y = float(y)
            z = float(z)
            for symop in data_block['_space_group_symop_operation_xyz']:
                x_eq, y_eq, z_eq = symop.split(',')
                x_new = eval(x_eq)
                y_new = eval(y_eq)
                z_new = eval(z_eq)
                # Translate into cell.
                x_new = x_new - math.floor(x_new)
                y_new = y_new - math.floor(y_new)
                z_new = z_new - math.floor(z_new)
                # check for almost 1, should be 0
                if abs(1 - x_new) < delta:
                    x_new = 0.0
                if abs(1 - y_new) < delta:
                    y_new = 0.0
                if abs(1 - z_new) < delta:
                    z_new = 0.0
                found = False
                for x0, y0, z0 in zip(xs, ys, zs):
                    if (
                        abs(x_new - x0) < delta and abs(y_new - y0) < delta and
                        abs(z_new - z0) < delta
                    ):
                        found = True
                        break
                if not found:
                    xs.append(x_new)
                    ys.append(y_new)
                    zs.append(z_new)
                    symbols.append(symbol)
            self.atoms.append(x=xs, y=ys, z=zs, symbol=symbols)

    def to_mmcif_text(self):
        """Create the text of a mmCIF file from this confguration.

        Returns
        -------
        text : str
            The text of the file.
        """

        lines = []

        atoms = self.atoms
        bonds = self.bonds

        # Get the chemical formula
        formula, empirical_formula, Z = self.formula

        _id = empirical_formula.replace(' ', '')

        # And created the file, line-by-line
        lines = []
        lines.append('# Generated by MolSSI SEAMM')
        lines.append(f"data_{_id}")
        lines.append(f"_chem_comp.name '{formula}'")
        lines.append(f"_chem_comp.id '{_id}'")
        lines.append(f"_chem_comp.formula   '{formula}'")

        # Cell information
        if self.periodicity == 3:
            cell = self.cell
            a, b, c, alpha, beta, gamma = cell.parameters
            volume = cell.volume
            lines.append("_symmetry_space_group_name_H-M   'P 1'")
            lines.append(f'_cell_length_a   {a}')
            lines.append(f'_cell_length_b   {b}')
            lines.append(f'_cell_length_c   {c}')
            lines.append(f'_cell_angle_alpha   {alpha}')
            lines.append(f'_cell_angle_beta    {beta}')
            lines.append(f'_cell_angle_gamma   {gamma}')
            lines.append('_symmetry_Int_Tables_number   1')
            lines.append(f'_cell_volume   {volume}')
            lines.append(f'_cell_formula_units_Z   {Z}')
            lines.append('loop_')
            lines.append(' _symmetry_equiv_pos_site_id')
            lines.append(' _symmetry_equiv_pos_as_xyz')
            lines.append("  1  'x, y, z'")

        lines.append(f"_chemical_formula_structural   '{empirical_formula}'")
        lines.append(f"_chemical_formula_sum   '{formula}'")

        # The atoms
        lines.append('loop_')
        lines.append(' _chem_comp_atom.comp_id')
        lines.append(' _chem_comp_atom.atom_id')
        lines.append(' _chem_comp_atom.type_symbol')
        lines.append(' _chem_comp_atom.model_Cartn_x')
        lines.append(' _chem_comp_atom.model_Cartn_y')
        lines.append(' _chem_comp_atom.model_Cartn_z')
        lines.append(' _chem_comp_atom.pdbx_model_Cartn_x_ideal')
        lines.append(' _chem_comp_atom.pdbx_model_Cartn_y_ideal')
        lines.append(' _chem_comp_atom.pdbx_model_Cartn_z_ideal')
        lines.append(' _chem_comp_atom.pdbx_component_comp_id')
        lines.append(' _chem_comp_atom.pdbx_residue_numbering')

        # Need unique names
        if 'names' in atoms:
            original_names = atoms.get_column('names')
        else:
            original_names = atoms.symbols

        names = []
        tmp = {}
        for name in original_names:
            if name in tmp:
                tmp[name] += 1
                names.append(name + str(tmp[name]))
            else:
                tmp[name] = 1
                names.append(name)

        XYZ = atoms.get_coordinates(in_cell='molecule')
        XYZa = atoms.get_coordinates(fractionals=False)

        symbols = atoms.symbols
        for element, name, xyza, xyz in zip(symbols, names, XYZa, XYZ):
            xa, ya, za = xyza
            x, y, z = xyz
            lines.append(
                f'MOL1 {name} {element} {xa:.3f} {ya:.3f} {za:.3f} '
                f'{x:.3f} {y:.3f} {z:.3f} HET 1'
            )

        # The bonds
        lines.append('#')
        lines.append('loop_')
        lines.append(' _chem_comp_bond.comp_id')
        lines.append(' _chem_comp_bond.atom_id_1')
        lines.append(' _chem_comp_bond.atom_id_2')
        lines.append(' _chem_comp_bond.value_order')
        for row in bonds.bonds():
            i = row['i']
            j = row['j']
            order = bond_order[row['bondorder']]
            nm1 = names[i - 1]
            nm2 = names[j - 1]
            lines.append(f'MOL1 {nm1} {nm2} {order}')

        # And that is it!
        return '\n'.join(lines)

    def from_mmcif_text(self, text):
        """Create this configuration from an MMCIF file..

        Parameters
        ----------
        text : str
            The text from the MMCIF file

        Returns
        -------
        None
        """
        cif = CifFile.ReadCif(io.StringIO(text))

        data_blocks = [*cif.keys()]

        if len(data_blocks) != 1:
            raise RuntimeError(
                f'There are {len(data_blocks)} data blocks in the mmcif file.'
            )
        data = cif[data_blocks[0]]

        # Reset the system
        self.clear()
        self.periodicity = 0
        self.coordinate_system = 'Cartesian'

        self.name = ''
        for key in [
            '_chem_comp.id', '_chem_comp.name', '_chem_comp.three_letter_code'
        ]:
            if key in data:
                self.name = data[key]
                break

        # Add the atoms
        kwargs = {}
        kwargs['x'] = [float(x) for x in data['_chem_comp_atom.model_Cartn_x']]
        kwargs['y'] = [float(y) for y in data['_chem_comp_atom.model_Cartn_y']]
        kwargs['z'] = [float(z) for z in data['_chem_comp_atom.model_Cartn_z']]
        kwargs['symbol'] = [s for s in data['_chem_comp_atom.type_symbol']]

        for cif_key, key, _type, default in [
            ('atom_id', 'name', 'str', ''),
            ('charge', 'formal_charge', 'int', 0),
            ('pdbx_align', None, 'int', 0),
            ('pdbx_aromatic_flag', None, 'bool', False),
            ('pdbx_leaving_atom_flag', None, 'bool', False),
            ('pdbx_stereo_config', None, 'bool', False),
            ('pdbx_component_atom_id', None, 'bool', False)
        ]:
            cif_key = '_chem_comp_atom.' + cif_key
            if cif_key in data:
                if key is None:
                    key = cif_key
                if _type == 'bool':
                    kwargs[key] = [x == 'N' for x in data[cif_key]]
                else:
                    kwargs[key] = [x for x in data[cif_key]]
                if key not in self.atoms:
                    self.atoms.add_attribute(key, _type, default=default)

        atom_ids = self.atoms.append(**kwargs)

        # Prepare for the bonds, which are labeled by atom name (id)
        atom_id = {name: _id for _id, name in zip(atom_ids, kwargs['name'])}

        # And the bonds
        kwargs = {}
        kwargs['i'] = [atom_id[x] for x in data['_chem_comp_bond.atom_id_1']]
        kwargs['j'] = [atom_id[x] for x in data['_chem_comp_bond.atom_id_2']]
        if '_chem_comp_bond.value_order' in data:
            kwargs['bondorder'] = [
                to_bond_order[x] for x in data['_chem_comp_bond.value_order']
            ]

        self.bonds.append(**kwargs)
